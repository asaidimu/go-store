{
  "system": {
    "name": "go-store",
    "repo": "github.com/asaidimu/go-store/v3",
    "language": "Go",
    "description": "An in-memory, concurrent-safe document store with indexing.",
    "keyFeatures": [
      "in-memory",
      "concurrency-safe",
      "indexing",
      "crud-operations",
      "document-streaming"
    ]
  },
  "dependencies": {
    "external": [
      {
        "name": "github.com/google/btree",
        "purpose": "Provides an efficient B-tree implementation used internally for maintaining sorted indexes, enabling fast lookups and range queries.",
        "installation": "go get github.com/google/btree",
        "version": ">=1.0.0"
      },
      {
        "name": "github.com/google/uuid",
        "purpose": "Used for generating universally unique identifiers (UUIDs) for document IDs, ensuring each document has a unique ID.",
        "installation": "go get github.com/google/uuid",
        "version": ">=1.0.0"
      }
    ],
    "peer": []
  },
  "integration": {
    "environmentRequirements": "Go Runtime Environment (Go 1.24.4+ recommended). No special compiler settings or platform constraints beyond standard Go compilation.",
    "initializationPatterns": [
      {
        "title": "The most common way to initialize the store and ensure proper resource cleanup upon application shutdown.",
        "description": "The `NewStore()` function initializes a new `Store` instance. It is crucial to defer the `Close()` method call immediately after initialization to ensure that all internal resources are properly released when the function or application exits.",
        "codeExample": "package main\n\nimport (\n\t\"fmt\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\t// Initialize a new store instance\n\ts := store.NewStore()\n\t// Defer the Close method call to ensure resources are released\n\t// when the main function exits.\n\tdefer s.Close()\n\n\tfmt.Println(\"Store initialized and ready for use.\")\n\n\t// ... perform store operations here ...\n}",
        "language": "go"
      }
    ],
    "commonPitfalls": [
      {
        "issue": "Forgetting to call `store.Close()`",
        "solution": "Always use `defer s.Close()` immediately after `s := store.NewStore()` to ensure resources are released and to aid garbage collection, especially in long-running applications."
      },
      {
        "issue": "Modifying `DocumentResult.Data` directly affects the stored document.",
        "solution": "`DocumentResult.Data` is a deep copy. Modifying it will NOT affect the internal state of the document in the store. To update a document, you must call `s.Update(id, newDocumentData)`."
      },
      {
        "issue": "Expecting data persistence across application restarts.",
        "solution": "`go-store` is an in-memory database. All data is lost when the application exits. For persistence, you need to implement external serialization/deserialization or use a persistent storage layer."
      }
    ],
    "lifecycleDependencies": "The `Store` instance should be initialized once at the application's startup phase (e.g., in `main` or a dedicated initialization function). Its `Close()` method should be called during the application's graceful shutdown procedure to release all allocated memory and resources. Operations performed on a `closed` store will result in `ErrStoreClosed`."
  },
  "interfaces": {
    "DocumentLike": {
      "id": "interface:DocumentLike",
      "definition": "type DocumentLike interface {\n\t~map[string]any\n}",
      "purpose": "A type constraint that allows any type alias of `map[string]any` to be used as a document within generic contexts like `Cursor`.",
      "related": {
        "methods": [],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "Cursor": {
      "id": "interface:Cursor",
      "definition": "type Cursor[T DocumentLike] interface {\n\tNext() (*T, bool /* has next */, error)\n\tPrevious() (*T, bool /* has previous */, error)\n\tAdvance(count int /* can be negative */) (*T, bool /* has next/previous depending on intended direction */, error)\n\tReset() error     // For algorithms that need multiple passes\n\tClone() Cursor[T] // For nested operations\n\tCount() int       // Maximum number of documents we can iterate over\n\tClose() error     // Clean up resources\n}",
      "purpose": "Provides a generic interface for bidirectional iteration over a collection of `DocumentLike` types, allowing flexible navigation and snapshot handling.",
      "related": {
        "methods": [
          "method:StoreCursor.Next",
          "method:StoreCursor.Previous",
          "method:StoreCursor.Advance",
          "method:StoreCursor.Reset",
          "method:StoreCursor.Clone",
          "method:StoreCursor.Count",
          "method:StoreCursor.Close"
        ],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": []
      },
      "interfaceContract": {
        "requiredMethods": [
          {
            "name": "Next",
            "signature": "Next() (*T, bool, error)",
            "parameters": {},
            "returnValue": "A pointer to the next document of type T, a boolean indicating if there are more documents, and an error if the stream is closed or the document is deleted.",
            "sideEffects": "Advances the cursor's internal position by one. May return `ErrStreamClosed` if called on a closed cursor or `ErrDocumentDeleted` if the document at the next position was removed."
          },
          {
            "name": "Previous",
            "signature": "Previous() (*T, bool, error)",
            "parameters": {},
            "returnValue": "A pointer to the previous document of type T, a boolean indicating if there are more documents, and an error.",
            "sideEffects": "Moves the cursor's internal position back by one. Equivalent to calling `Advance(-1)`."
          },
          {
            "name": "Advance",
            "signature": "Advance(count int) (*T, bool, error)",
            "parameters": {
              "count int": "The number of positions to move the cursor. Can be positive (forward) or negative (backward)."
            },
            "returnValue": "A pointer to the document at the new position, a boolean indicating if there are more documents in the direction of advance, and an error.",
            "sideEffects": "Adjusts the cursor's internal position by `count`. Clamps to the start or end of the document list if `count` would move it out of bounds."
          },
          {
            "name": "Reset",
            "signature": "Reset() error",
            "parameters": {},
            "returnValue": "`nil` on success, `ErrStreamClosed` if the cursor is already closed.",
            "sideEffects": "Resets the cursor's internal position to the beginning (index 0) of its document snapshot."
          },
          {
            "name": "Clone",
            "signature": "Clone() Cursor[T]",
            "parameters": {},
            "returnValue": "A new `Cursor` instance that is an independent copy of the current cursor, starting at the same position and referencing the same document snapshot.",
            "sideEffects": "None directly on the original cursor; creates a new object."
          },
          {
            "name": "Count",
            "signature": "Count() int",
            "parameters": {},
            "returnValue": "The total number of documents in the cursor's snapshot.",
            "sideEffects": "None (read-only operation)."
          },
          {
            "name": "Close",
            "signature": "Close() error",
            "parameters": {},
            "returnValue": "`nil` on success.",
            "sideEffects": "Marks the cursor as closed and releases its internal reference to the document handles, aiding garbage collection."
          }
        ],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "Document": {
      "id": "interface:Document",
      "definition": "type Document map[string]any",
      "purpose": "Represents a flexible, schemaless document in the store. It's a map where keys are string field names and values can be of any Go type (including nested maps, slices, and primitive types).",
      "related": {
        "methods": [
          "method:Insert",
          "method:Update",
          "method:Get",
          "method:Stream"
        ],
        "types": [],
        "patterns": [
          "pattern:Basic Document CRUD"
        ]
      },
      "interfaceContract": {
        "requiredMethods": [],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    },
    "DocumentStream": {
      "id": "interface:DocumentStream",
      "definition": "type DocumentStream struct {\n    results chan DocumentResult\n    errors  chan error\n    ctx     context.Context\n    cancel  context.CancelFunc\n}",
      "purpose": "Provides an iterator-like interface for streaming documents from the store. It allows consuming documents asynchronously and efficiently without loading all results into memory at once.",
      "related": {
        "methods": [
          "method:Stream",
          "method:DocumentStream.Next",
          "method:DocumentStream.Close"
        ],
        "types": [],
        "patterns": [
          "pattern:Streaming Documents"
        ]
      },
      "interfaceContract": {
        "requiredMethods": [
          {
            "name": "Next",
            "signature": "func (ds *DocumentStream) Next() (DocumentResult, error)",
            "parameters": {},
            "returnValue": "A `DocumentResult` struct containing the document ID, a deep copy of its data, and its version. If the stream is exhausted or closed, `DocumentResult{}` is returned with an error.",
            "sideEffects": "Consumes the next available document from the internal channel. If the channel is empty, it blocks until a document is available, an error occurs, or the stream is closed/cancelled."
          },
          {
            "name": "Close",
            "signature": "func (ds *DocumentStream) Close()",
            "parameters": {},
            "returnValue": "None",
            "sideEffects": "Cancels the stream's internal `context.Context` and closes its `results` and `errors` channels. Any pending `Next()` calls will be unblocked and return `ErrStreamClosed` or a context-related error."
          }
        ],
        "optionalMethods": [],
        "parameterObjectStructures": {}
      }
    }
  },
  "types": {
    "DocumentResult": {
      "id": "type:DocumentResult",
      "definition": "type DocumentResult struct {\n    ID      string   // Document identifier\n    Data    Document // Document data (deep copy)\n    Version uint64   // Document version\n}",
      "purpose": "Represents a snapshot of a document returned from a query or retrieval operation. It includes the document's unique identifier, a deep copy of its data, and its current version number.",
      "related": {
        "interfaces": [],
        "methods": [
          "method:Get",
          "method:Stream",
          "method:Lookup",
          "method:LookupRange"
        ],
        "patterns": []
      }
    }
  },
  "methods": {
    "NewStore": {
      "id": "method:NewStore",
      "useCase": "To initialize a new, empty in-memory document store. This must be the first call before performing any other store operations.",
      "signature": "func NewStore() *Store",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "Allocates and initializes internal data structures for documents and indexes.",
      "returnValue": "A pointer to a new `Store` instance (`*Store`).",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Basic Document CRUD"
        ],
        "errors": []
      }
    },
    "Insert": {
      "id": "method:Insert",
      "useCase": "To add a new document to the store. A unique ID is automatically generated for the document.",
      "signature": "func (s *Store) Insert(doc Document) (string, error)",
      "parameters": {
        "doc Document": "The document data (`map[string]any`) to be inserted. Must not be `nil`."
      },
      "prerequisites": "The store must not be closed. The `doc` parameter must not be `nil`.",
      "sideEffects": "Generates a new UUID for the document. Creates a new `DocumentHandle` and `DocumentSnapshot`. Adds the document to the store's internal map. Increments the global store version. Updates all active indexes to include the new document.",
      "returnValue": "The generated unique identifier (`string`) for the new document and an `error` if the operation fails.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrInvalidDocument"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Basic Document CRUD"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrInvalidDocument"
        ]
      }
    },
    "Update": {
      "id": "method:Update",
      "useCase": "To modify an existing document identified by its ID. The provided document data completely replaces the existing data.",
      "signature": "func (s *Store) Update(docID string, doc Document) error",
      "parameters": {
        "docID string": "The unique identifier of the document to update.",
        "doc Document": "The new document data (`map[string]any`). Must not be `nil`. This data will completely replace the old document's data."
      },
      "prerequisites": "The store must not be closed. The `doc` parameter must not be `nil`. A document with the given `docID` must exist in the store and not have been concurrently deleted.",
      "sideEffects": "Creates a new `DocumentSnapshot` with the updated data and an incremented version. Atomically replaces the old snapshot in the `DocumentHandle`. Updates all active indexes if the fields relevant to those indexes have changed. Releases the old `DocumentSnapshot` when no longer referenced.",
      "returnValue": "`nil` on successful update, or an `error` if the document is not found, the store is closed, or the input is invalid.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrInvalidDocument",
        "ErrDocumentNotFound",
        "ErrDocumentDeleted"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Basic Document CRUD",
          "pattern:Concurrent Update Pattern"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrInvalidDocument",
          "error:ErrDocumentNotFound",
          "error:ErrDocumentDeleted"
        ]
      }
    },
    "Delete": {
      "id": "method:Delete",
      "useCase": "To permanently remove a document from the store.",
      "signature": "func (s *Store) Delete(docID string) error",
      "parameters": {
        "docID string": "The unique identifier of the document to delete."
      },
      "prerequisites": "The store must not be closed. A document with the given `docID` must exist.",
      "sideEffects": "Removes the `DocumentHandle` from the store's internal map. Removes the document's entry from all active indexes. Releases the `DocumentSnapshot` associated with the deleted document when its reference count drops to zero.",
      "returnValue": "`nil` on successful deletion, or an `error` if the document is not found or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrDocumentNotFound"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Basic Document CRUD"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrDocumentNotFound"
        ]
      }
    },
    "Get": {
      "id": "method:Get",
      "useCase": "To retrieve a single document by its unique identifier.",
      "signature": "func (s *Store) Get(docID string) (*DocumentResult, error)",
      "parameters": {
        "docID string": "The unique identifier of the document to retrieve."
      },
      "prerequisites": "The store must not be closed. The document with `docID` must exist and not have been deleted.",
      "sideEffects": "None (read-only operation).",
      "returnValue": "A pointer to a `DocumentResult` containing the document's ID, a deep copy of its data, and its version. Returns `nil` and an `error` if the document is not found, has been deleted, or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrDocumentNotFound",
        "ErrDocumentDeleted"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": [
          "pattern:Basic Document CRUD"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrDocumentNotFound",
          "error:ErrDocumentDeleted"
        ]
      }
    },
    "Stream": {
      "id": "method:Stream",
      "useCase": "To obtain an iterator-like stream for efficiently processing all documents currently in the store without loading them all into memory at once. It provides a consistent snapshot of documents at the time of its creation.",
      "signature": "func (s *Store) Stream(bufferSize int) *DocumentStream",
      "parameters": {
        "bufferSize int": "The size of the internal channel buffer. A value of 0 creates an unbuffered channel."
      },
      "prerequisites": "The store must not be closed.",
      "sideEffects": "Initializes a new `DocumentStream` and starts a goroutine to populate it with documents from the store's current snapshot. This is a read-only operation and does not modify the store's state.",
      "returnValue": "A pointer to a new `DocumentStream` instance. You must call `DocumentStream.Close()` on the returned stream when you are finished consuming documents to release resources.",
      "exceptions": [
        "ErrStoreClosed"
      ],
      "availability": "async",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Streaming Documents"
        ],
        "errors": [
          "error:ErrStoreClosed"
        ]
      }
    },
    "CreateIndex": {
      "id": "method:CreateIndex",
      "useCase": "To build a new B-tree based index on one or more specified document fields. This enables fast exact and range lookups.",
      "signature": "func (s *Store) CreateIndex(indexName string, fields []string) error",
      "parameters": {
        "indexName string": "A unique name for the new index.",
        "fields []string": "A slice of strings specifying the document fields to index. The order of fields matters for composite indexes. Must not be empty."
      },
      "prerequisites": "The store must not be closed. The `indexName` must be unique (an index with the same name must not already exist). The `fields` slice must not be empty.",
      "sideEffects": "Allocates memory for a new `fieldIndex` (B-tree). Populates the new index with existing documents from the store that contain all specified fields. Adds the new index to the store's internal index map.",
      "returnValue": "`nil` on successful index creation, or an `error` if the index name already exists, the `fields` slice is empty, or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrEmptyIndex",
        "ErrIndexExists"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Indexed Lookup"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrEmptyIndex",
          "error:ErrIndexExists"
        ]
      }
    },
    "DropIndex": {
      "id": "method:DropIndex",
      "useCase": "To remove an existing index from the store, freeing up its associated memory.",
      "signature": "func (s *Store) DropIndex(indexName string) error",
      "parameters": {
        "indexName string": "The name of the index to remove."
      },
      "prerequisites": "The store must not be closed. An index with the given `indexName` must exist.",
      "sideEffects": "Removes the specified index from the store's internal index map. Releases the memory allocated by the index's B-tree and its entries.",
      "returnValue": "`nil` on successful index removal, or an `error` if the index does not exist or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrIndexNotFound"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrIndexNotFound"
        ]
      }
    },
    "Lookup": {
      "id": "method:Lookup",
      "useCase": "To find documents that exactly match a given set of values on an existing index.",
      "signature": "func (s *Store) Lookup(indexName string, values []any) ([]*DocumentResult, error)",
      "parameters": {
        "indexName string": "The name of the index to use for the lookup.",
        "values []any": "A slice of values to match against the index. For composite indexes, the order of values must match the order of fields used during index creation."
      },
      "prerequisites": "The store must not be closed. An index with the given `indexName` must exist.",
      "sideEffects": "None (read-only operation).",
      "returnValue": "A slice of pointers to `DocumentResult` instances that match the query. Returns an empty slice if no documents are found, or `nil` and an `error` if the index does not exist or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrIndexNotFound"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": [
          "pattern:Indexed Lookup"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrIndexNotFound"
        ]
      }
    },
    "LookupRange": {
      "id": "method:LookupRange",
      "useCase": "To find documents within a specified range of values on an existing index. This is particularly useful for numerical or lexicographically sortable fields.",
      "signature": "func (s *Store) LookupRange(indexName string, minValues, maxValues []any) ([]*DocumentResult, error)",
      "parameters": {
        "indexName string": "The name of the index to use for the range lookup.",
        "minValues []any": "A slice of values defining the lower bound of the range (inclusive).",
        "maxValues []any": "A slice of values defining the upper bound of the range (inclusive)."
      },
      "prerequisites": "The store must not be closed. An index with the given `indexName` must exist. The `minValues` should logically precede or be equal to `maxValues` according to the index's sorting logic, otherwise an empty result set will be returned.",
      "sideEffects": "None (read-only operation).",
      "returnValue": "A slice of pointers to `DocumentResult` instances that fall within the specified range. Returns an empty slice if no documents are found within the range, or `nil` and an `error` if the index does not exist or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrIndexNotFound"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": [
          "pattern:Indexed Lookup"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrIndexNotFound"
        ]
      }
    },
    "DocumentStream.Next": {
      "id": "method:DocumentStream.Next",
      "useCase": "To retrieve the next available document from an active stream. This method blocks until a document is available, the stream is closed, or an error occurs.",
      "signature": "func (ds *DocumentStream) Next() (DocumentResult, error)",
      "parameters": {},
      "prerequisites": "The `DocumentStream` must be active (not closed yet).",
      "sideEffects": "Consumes one document from the internal stream channel.",
      "returnValue": "A `DocumentResult` struct if a document is available. Returns an empty `DocumentResult{}` and an `error` if the stream is closed, exhausted, or encounters an issue (e.g., context cancellation).",
      "exceptions": [
        "ErrStreamClosed",
        "context.Canceled",
        "context.DeadlineExceeded"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [
          "type:DocumentResult"
        ],
        "patterns": [
          "pattern:Streaming Documents"
        ],
        "errors": [
          "error:ErrStreamClosed"
        ]
      }
    },
    "DocumentStream.Close": {
      "id": "method:DocumentStream.Close",
      "useCase": "To explicitly close a `DocumentStream`, releasing its resources and signaling that no more documents should be processed. This is crucial for resource management, especially when you stop consuming documents early.",
      "signature": "func (ds *DocumentStream) Close()",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "Cancels the stream's internal `context.Context` and closes its `results` and `errors` channels. Any pending `Next()` calls will be unblocked and return `ErrStreamClosed` or a context-related error.",
      "returnValue": "None",
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [
          "pattern:Streaming Documents"
        ],
        "errors": []
      }
    },
    "Store.Close": {
      "id": "method:Store.Close",
      "useCase": "To gracefully shut down the store and release all associated resources. This should be called when the application no longer needs the store.",
      "signature": "func (s *Store) Close()",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "Sets the store's internal `closed` flag to true, preventing any further operations. Clears the `documents` and `indexes` maps to aid Go's garbage collection. Releases all `DocumentSnapshot` resources once their reference counts drop to zero.",
      "returnValue": "None",
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStoreClosed"
        ]
      }
    },
    "Store.Read": {
      "id": "method:Store.Read",
      "useCase": "To create a cursor that provides bidirectional iteration over all documents currently in the store. This creates a snapshot of the store's documents at the time of the call.",
      "signature": "func (s *Store) Read() (*StoreCursor[map[string]any], error)",
      "parameters": {},
      "prerequisites": "The store must not be closed.",
      "sideEffects": "Creates a snapshot of current document handles in the store. Sorts the handles by their internal collection index to ensure a consistent iteration order.",
      "returnValue": "A pointer to a `StoreCursor` instance that can be used to iterate over documents, or an error if the store is closed.",
      "exceptions": [
        "ErrStoreClosed"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStoreClosed"
        ]
      }
    },
    "Store.ReadIndex": {
      "id": "method:Store.ReadIndex",
      "useCase": "To create a cursor that iterates over documents included in a specific index. Documents are returned in the order defined by the index's fields.",
      "signature": "func (s *Store) ReadIndex(indexName string) (*StoreCursor[map[string]any], error)",
      "parameters": {
        "indexName string": "The name of the index to read documents from."
      },
      "prerequisites": "The store must not be closed. An index with the given `indexName` must exist.",
      "sideEffects": "Collects document handles associated with the specified index.",
      "returnValue": "A pointer to a `StoreCursor` instance filtered by the specified index, or an error if the index does not exist or the store is closed.",
      "exceptions": [
        "ErrStoreClosed",
        "ErrIndexNotFound"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [
          "pattern:Indexed Lookup"
        ],
        "errors": [
          "error:ErrStoreClosed",
          "error:ErrIndexNotFound"
        ]
      }
    },
    "StoreCursor.Next": {
      "id": "method:StoreCursor.Next",
      "useCase": "To retrieve the next document from the cursor's snapshot and advance its position by one. This is typically used for forward iteration.",
      "signature": "func (sc *StoreCursor[T]) Next() (*T, bool, error)",
      "parameters": {},
      "prerequisites": "The `StoreCursor` must not be closed.",
      "sideEffects": "Increments the cursor's internal position. May return `ErrDocumentDeleted` if the document at the next position was removed from the underlying collection since the cursor was created.",
      "returnValue": "A pointer to the next document (`*T`), a boolean indicating if there are more documents after the current one, and an `error` if the cursor is closed or the document is no longer available.",
      "exceptions": [
        "ErrStreamClosed",
        "ErrDocumentDeleted"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStreamClosed",
          "error:ErrDocumentDeleted"
        ]
      }
    },
    "StoreCursor.Previous": {
      "id": "method:StoreCursor.Previous",
      "useCase": "To retrieve the previous document from the cursor's snapshot and move its position backward by one. This is typically used for backward iteration.",
      "signature": "func (sc *StoreCursor[T]) Previous() (*T, bool, error)",
      "parameters": {},
      "prerequisites": "The `StoreCursor` must not be closed.",
      "sideEffects": "Decrements the cursor's internal position. This method is a convenience wrapper around `Advance(-1)`.",
      "returnValue": "A pointer to the previous document (`*T`), a boolean indicating if there are more documents before the current one, and an `error` if the cursor is closed or the document is no longer available.",
      "exceptions": [
        "ErrStreamClosed",
        "ErrDocumentDeleted"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStreamClosed",
          "error:ErrDocumentDeleted"
        ]
      }
    },
    "StoreCursor.Advance": {
      "id": "method:StoreCursor.Advance",
      "useCase": "To move the cursor's position by a specified `count` and retrieve the document at the new position. This allows flexible navigation (forward or backward) within the cursor's snapshot.",
      "signature": "func (sc *StoreCursor[T]) Advance(count int) (*T, bool, error)",
      "parameters": {
        "count int": "The number of positions to move the cursor. Positive values move forward, negative values move backward. The cursor position will be clamped to the valid range if the count would exceed bounds."
      },
      "prerequisites": "The `StoreCursor` must not be closed.",
      "sideEffects": "Adjusts the cursor's internal position. If the requested position is out of bounds, the cursor is clamped to the first or last valid document. May return `ErrDocumentDeleted`.",
      "returnValue": "A pointer to the document (`*T`) at the new position, a boolean indicating if there are more documents in the direction of the advance (relative to the clamped position), and an `error` if the cursor is closed or the document is no longer available.",
      "exceptions": [
        "ErrStreamClosed",
        "ErrDocumentDeleted"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStreamClosed",
          "error:ErrDocumentDeleted"
        ]
      }
    },
    "StoreCursor.Reset": {
      "id": "method:StoreCursor.Reset",
      "useCase": "To reset the cursor's internal position back to the very first document in its snapshot. Useful for performing multiple passes over the same data set.",
      "signature": "func (sc *StoreCursor[T]) Reset() error",
      "parameters": {},
      "prerequisites": "The `StoreCursor` must not be closed.",
      "sideEffects": "Sets the cursor's internal position to 0.",
      "returnValue": "`nil` on success, or `ErrStreamClosed` if the cursor is already closed.",
      "exceptions": [
        "ErrStreamClosed"
      ],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": [
          "error:ErrStreamClosed"
        ]
      }
    },
    "StoreCursor.Clone": {
      "id": "method:StoreCursor.Clone",
      "useCase": "To create an independent copy of the current `StoreCursor` instance. The cloned cursor starts at the same position and refers to the same immutable snapshot of documents.",
      "signature": "func (sc *StoreCursor[T]) Clone() Cursor[T]",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "Creates a new `StoreCursor` object. Does not affect the original cursor.",
      "returnValue": "A new `Cursor` interface (`Cursor[T]`) instance that is a copy of the original. If the original cursor is closed, the cloned cursor will also be closed.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": []
      }
    },
    "StoreCursor.Count": {
      "id": "method:StoreCursor.Count",
      "useCase": "To get the total number of documents available in the cursor's current snapshot. This reflects the count at the time the cursor was created.",
      "signature": "func (sc *StoreCursor[T]) Count() int",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "None (read-only operation).",
      "returnValue": "An `int` representing the total count of documents in the snapshot. Returns 0 if the cursor is closed or has no documents.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": []
      }
    },
    "StoreCursor.Close": {
      "id": "method:StoreCursor.Close",
      "useCase": "To explicitly close the `StoreCursor`, releasing its internal resources and marking it as unusable for further iteration. This is important for memory management.",
      "signature": "func (sc *StoreCursor[T]) Close() error",
      "parameters": {},
      "prerequisites": "None.",
      "sideEffects": "Sets the `closed` flag to `true` and sets its internal `handles` slice to `nil`, allowing it to be garbage collected.",
      "returnValue": "`nil` on success. Calling `Close()` multiple times has no additional effect.",
      "exceptions": [],
      "availability": "sync",
      "status": "active",
      "related": {
        "interfaces": [
          "interface:Cursor"
        ],
        "types": [],
        "patterns": [],
        "errors": []
      }
    }
  },
  "decisionTrees": {},
  "patterns": {
    "Basic Document CRUD": {
      "id": "pattern:Basic Document CRUD",
      "description": "The fundamental pattern for creating, reading, updating, and deleting documents within the store.",
      "example": {
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t// Insert\n\tdoc := store.Document{\"name\": \"Example\", \"value\": 10}\n\tid, err := s.Insert(doc)\n\tif err != nil { log.Fatalf(\"Insert failed: %v\", err) }\n\tfmt.Printf(\"Inserted ID: %s\\n\", id)\n\n\t// Get\n\tretrieved, err := s.Get(id)\n\tif err != nil { log.Fatalf(\"Get failed: %v\", err) }\n\tfmt.Printf(\"Retrieved: %+v\\n\", retrieved.Data)\n\n\t// Update\n\tupdatedDoc := store.Document{\"name\": \"Updated Example\", \"value\": 20, \"status\": \"done\"}\n\terr = s.Update(id, updatedDoc)\n\tif err != nil { log.Fatalf(\"Update failed: %v\", err) }\n\tfmt.Println(\"Document updated.\")\n\n\t// Delete\n\terr = s.Delete(id)\n\tif err != nil { log.Fatalf(\"Delete failed: %v\", err) }\n\tfmt.Println(\"Document deleted.\")\n}",
        "validation": "Successful execution logs indicating document creation, retrieval, update, and deletion without errors. Attempting to retrieve after delete results in 'document not found' error."
      },
      "related": {
        "interfaces": [],
        "methods": [
          "method:Insert",
          "method:Get",
          "method:Update",
          "method:Delete"
        ],
        "errors": [
          "error:ErrDocumentNotFound",
          "error:ErrInvalidDocument"
        ]
      }
    },
    "Indexed Lookup": {
      "id": "pattern:Indexed Lookup",
      "description": "How to create and utilize indexes for efficient exact and range-based document retrieval.",
      "example": {
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t// Insert sample data\n\ts.Insert(store.Document{\"city\": \"New York\", \"age\": 30})\n\ts.Insert(store.Document{\"city\": \"London\", \"age\": 25})\n\ts.Insert(store.Document{\"city\": \"New York\", \"age\": 35})\n\n\t// Create an index\n\terr := s.CreateIndex(\"by_city_age\", []string{\"city\", \"age\"})\n\tif err != nil { log.Fatalf(\"CreateIndex failed: %v\", err) }\n\tfmt.Println(\"Index 'by_city_age' created.\")\n\n\t// Exact Lookup\n\tny30Docs, err := s.Lookup(\"by_city_age\", []any{\"New York\", 30})\n\tif err != nil { log.Fatalf(\"Lookup failed: %v\", err) }\n\tfmt.Printf(\"\\nDocs in NY, age 30: %d\\n\", len(ny30Docs))\n\tfor _, doc := range ny30Docs { fmt.Printf(\"  %+v\\n\", doc.Data) }\n\n\t// Range Lookup\n\tageRangeDocs, err := s.LookupRange(\"by_city_age\", []any{\"New York\", 20}, []any{\"New York\", 40})\n\tif err != nil { log.Fatalf(\"LookupRange failed: %v\", err) }\n\tfmt.Printf(\"\\nDocs in NY, age 20-40: %d\\n\", len(ageRangeDocs))\n\tfor _, doc := range ageRangeDocs { fmt.Printf(\"  %+v\\n\", doc.Data) }\n}",
        "validation": "The output should correctly list documents matching the exact lookup (`New York`, `30`) and the range lookup (`New York`, `20-40`). The number of results should match the expected count based on inserted data."
      },
      "related": {
        "interfaces": [],
        "methods": [
          "method:CreateIndex",
          "method:Lookup",
          "method:LookupRange"
        ],
        "errors": [
          "error:ErrIndexNotFound",
          "error:ErrIndexExists"
        ]
      }
    },
    "Streaming Documents": {
      "id": "pattern:Streaming Documents",
      "description": "Iterating over all documents in the store efficiently using `DocumentStream`.",
      "example": {
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t// Insert some documents\n\tfor i := 0; i < 5; i++ {\n\t\ts.Insert(store.Document{\"item\": fmt.Sprintf(\"Item%d\", i)})\n\t}\n\n\t// Create and consume a stream\n\tstream := s.Stream(2) // Buffered stream\n\tdefer stream.Close() // Important to close the stream\n\n\tcount := 0\n\tfor {\n\t\tdoc, err := stream.Next()\n\t\tif err != nil {\n\t\t\tif err == store.ErrStreamClosed { break }\n\t\t\tlog.Fatalf(\"Stream error: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"Streamed: %s\\n\", doc.Data[\"item\"])\n\t\tcount++\n\t}\n\tfmt.Printf(\"Total streamed documents: %d\\n\", count)\n}",
        "validation": "The program should print 'Streamed: ItemX' for each item inserted, and the final count should match the number of inserted documents. `ErrStreamClosed` should be returned at the end, not other errors."
      },
      "related": {
        "interfaces": [],
        "methods": [
          "method:Stream",
          "method:DocumentStream.Next",
          "method:DocumentStream.Close"
        ],
        "errors": [
          "error:ErrStreamClosed"
        ]
      }
    },
    "Concurrent Update Pattern": {
      "id": "pattern:Concurrent Update Pattern",
      "description": "Demonstrates how `go-store` handles multiple goroutines updating the same document safely using its optimistic concurrency control.",
      "example": {
        "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\tid, _ := s.Insert(store.Document{\"counter\": 0})\n\n\tvar wg sync.WaitGroup\n\tconst numUpdates = 100\n\n\tfor i := 0; i < numUpdates; i++ {\n\t\twg.Add(1)\n\t\tgo func(val int) {\n\t\t\tdefer wg.Done()\n\t\t\t// Each goroutine tries to update the counter to its iteration value\n\t\t\terr := s.Update(id, store.Document{\"counter\": val})\n\t\t\tif err != nil {\n\t\t\t\t// ErrDocumentNotFound is expected if another goroutine deletes it\n\t\t\t\tfmt.Printf(\"Update %d failed: %v\\n\", val, err)\n\t\t\t}\n\t\t}(i + 1)\n\t}\n\twg.Wait()\n\n\tfinalDoc, err := s.Get(id)\n\tif err != nil { log.Fatalf(\"Failed to get final doc: %v\", err) }\n\tfmt.Printf(\"Final Counter: %v, Final Version: %d\\n\", finalDoc.Data[\"counter\"], finalDoc.Version)\n\n\t// The final counter might be any of the update values, but the version\n\t// will be numUpdates + 1 (initial insert + all updates).\n\tif finalDoc.Version != uint64(numUpdates+1) {\n\t\tlog.Printf(\"WARNING: Expected version %d, got %d. This indicates a potential test scenario issue, not a bug.\", numUpdates+1, finalDoc.Version)\n\t}\n}",
        "validation": "The `Final Version` printed should be `101` (1 initial insert + 100 updates), demonstrating that all update attempts were processed, even if their `counter` values were overwritten. The `Final Counter` will be the value from the last successful update."
      },
      "related": {
        "interfaces": [],
        "methods": [
          "method:Update",
          "method:Get"
        ],
        "errors": [
          "error:ErrDocumentNotFound",
          "error:ErrDocumentDeleted"
        ]
      }
    }
  },
  "errors": {
    "ErrDocumentNotFound": {
      "id": "error:ErrDocumentNotFound",
      "type": "error",
      "symptoms": "A `*DocumentResult` pointer is `nil` and the returned `error` is `ErrDocumentNotFound` from `Get`, `Update`, `Delete`, `Lookup`, or `LookupRange` operations.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Attempting to retrieve a document with an ID that has never been inserted or has been successfully deleted.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\t_, err := s.Get(\"non-existent-id\")\n\tif err == store.ErrDocumentNotFound {\n\t\tfmt.Println(\"Successfully caught ErrDocumentNotFound for non-existent ID.\")\n\t}\n}",
          "reason": "The provided `docID` does not correspond to any active document in the store's internal map."
        },
        {
          "trigger": "Attempting to update or delete a document that has already been deleted (possibly by another concurrent operation).",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\tid, _ := s.Insert(store.Document{\"foo\": \"bar\"})\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t// This goroutine deletes the document\n\t\terr := s.Delete(id)\n\t\tif err != nil && err != store.ErrDocumentNotFound { log.Println(err) }\n\t\tfmt.Println(\"Deleter finished.\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t_ = s.Update(id, store.Document{\"foo\": \"baz\"})\n\t\tif err := s.Update(id, store.Document{\"foo\": \"baz\"}); err == store.ErrDocumentNotFound {\n\t\t\tfmt.Println(\"Updater caught ErrDocumentNotFound (document was deleted by other goroutine).\")\n\t\t}\n\t}()\n\twg.Wait()\n}",
          "reason": "The document's handle or associated snapshot was removed from the store before the operation could complete."
        }
      ],
      "diagnosis": "Verify the `docID` or index `values` used. If expected to exist, check if a preceding `Delete` operation or a concurrent process might have removed it. For lookups, ensure the index name is correct and values match the index definition.",
      "resolution": "For `Get`, `Update`, `Delete`: Ensure the document ID is correct and valid. If it's a transient condition due to concurrency, consider retry logic or design your application to gracefully handle non-existent documents. For `Lookup`/`LookupRange`: Ensure `indexName` is correct and `values` (or `minValues`/`maxValues`) are consistent with the index definition.",
      "prevention": "Implement ID validation. For concurrent scenarios, use patterns like idempotency or ensure operations are coordinated if a document's presence is strictly required. For indexes, ensure correct index names and field values are consistently used.",
      "handlingPatterns": "Typically handled by checking `if err == store.ErrDocumentNotFound { ... }` and providing user feedback (e.g., \"Item not found\") or skipping the operation. No recovery is possible if the document is truly absent.",
      "propagationBehavior": "Bubbles up to the caller of the `Store` method. It is not caught internally by the store.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:Get",
          "method:Update",
          "method:Delete",
          "method:Lookup",
          "method:LookupRange"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrDocumentDeleted": {
      "id": "error:ErrDocumentDeleted",
      "type": "error",
      "symptoms": "Returned by `Get` or `Update` if the document was previously logically deleted (its `DocumentHandle`'s snapshot pointer was set to `nil`) but its `DocumentHandle` still exists in the map (e.g., during a race condition between `Get`/`Update` and `Delete`).",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "A `Get` or `Update` operation races with a `Delete` operation. The document's `DocumentHandle` might still be in the `Store.documents` map, but its internal `current` snapshot pointer has been set to `nil` by the `Delete` operation.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\tid, _ := s.Insert(store.Document{\"key\": \"value\"})\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(1 * time.Millisecond) // Give updater a chance to start\n\t\t_ = s.Delete(id)\n\t\tfmt.Println(\"Deleter finished.\")\n\t}()\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t_, err := s.Get(id)\n\t\tif err == store.ErrDocumentDeleted {\n\t\t\tfmt.Println(\"Getter caught ErrDocumentDeleted: document was concurrently deleted.\")\n\t\t} else if err != nil {\n\t\t\tfmt.Printf(\"Getter caught unexpected error: %v\\n\", err)\n\t\t}\n\t}()\n\twg.Wait()\n}",
          "reason": "The underlying `DocumentSnapshot` has been marked for deletion (its pointer set to nil), even if the `DocumentHandle` itself hasn't been completely removed from the store's map yet. This indicates the document is no longer active."
        }
      ],
      "diagnosis": "This error is transient and indicates a race condition where a document was accessed after it began its deletion process. It's often followed shortly by `ErrDocumentNotFound` if the `Delete` fully completes. This usually signifies that the document is indeed gone.",
      "resolution": "Treat `ErrDocumentDeleted` similarly to `ErrDocumentNotFound` in most application logic. It implies the document is no longer available. In robust concurrent systems, you might retry the operation if it was an update, but for `Get` it means the data is not there.",
      "prevention": "While hard to prevent race conditions entirely in high concurrency, ensuring that client-side operations account for documents potentially being deleted by other threads is key.",
      "handlingPatterns": "Check `if err == store.ErrDocumentDeleted || err == store.ErrDocumentNotFound { ... }` to handle both states as an absent document. Log the error for debugging if unexpected, but don't typically retry immediately unless your application logic specifically requires it for idempotent operations.",
      "propagationBehavior": "Bubbles up to the caller of the `Store` method. It is not caught internally by the store.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:Get",
          "method:Update"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrIndexExists": {
      "id": "error:ErrIndexExists",
      "type": "error",
      "symptoms": "Calling `CreateIndex` with an `indexName` that is already in use by an existing index.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Attempting to create an index with a name that is already assigned to another index in the store.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t_ = s.CreateIndex(\"my_index\", []string{\"field1\"})\n\n\terr := s.CreateIndex(\"my_index\", []string{\"field2\"})\n\tif err == store.ErrIndexExists {\n\t\tfmt.Println(\"Successfully caught ErrIndexExists.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "The `Store` maintains a map of indexes by their unique names. An attempt was made to add a new entry with a key that already exists."
        }
      ],
      "diagnosis": "Verify index names before creation. Check if your application logic attempts to create the same index multiple times without prior checks or dropping.",
      "resolution": "Choose a unique name for your new index. If you intend to redefine an existing index, `DropIndex` it first, then `CreateIndex`.",
      "prevention": "Use a consistent naming convention for indexes. Check for index existence with a `Lookup` (which would return `ErrIndexNotFound` if not present) before attempting `CreateIndex` if dynamic index management is needed, or ensure `CreateIndex` is called only once during initialization.",
      "handlingPatterns": "Catch `ErrIndexExists` and log it, or skip index creation if the goal is to ensure an index exists but not necessarily create a new one every time. If redefining is truly intended, follow `DropIndex` with `CreateIndex`.",
      "propagationBehavior": "Bubbles up to the caller of `CreateIndex`.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:CreateIndex"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrEmptyIndex": {
      "id": "error:ErrEmptyIndex",
      "type": "error",
      "symptoms": "Calling `CreateIndex` with an empty slice (`[]string{}`) for the `fields` parameter.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Providing an empty slice of field names when creating a new index.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\terr := s.CreateIndex(\"invalid_index\", []string{})\n\tif err == store.ErrEmptyIndex {\n\t\tfmt.Println(\"Successfully caught ErrEmptyIndex.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "An index requires at least one field to be defined for its keys. An empty `fields` slice is logically invalid for a B-tree index."
        }
      ],
      "diagnosis": "Review the `fields` parameter passed to `CreateIndex`. Ensure it contains at least one valid string representing a document field.",
      "resolution": "Provide a non-empty slice of field names. For example, `[]string{\"name\"}` or `[]string{\"city\", \"age\"}`.",
      "prevention": "Add input validation on the `fields` slice before calling `CreateIndex` if the field names are user-provided or dynamically generated.",
      "handlingPatterns": "Catch `ErrEmptyIndex` and return a user-friendly error message, or correct the `fields` input.",
      "propagationBehavior": "Bubbles up to the caller of `CreateIndex`.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:CreateIndex"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrIndexNotFound": {
      "id": "error:ErrIndexNotFound",
      "type": "error",
      "symptoms": "Returned by `DropIndex`, `Lookup`, or `LookupRange` when the specified `indexName` does not correspond to any active index in the store.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Attempting to query or drop an index that has not been created or has already been dropped.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t// Try to lookup using a non-existent index\n\t_, err := s.Lookup(\"non_existent_index\", []any{\"value\"})\n\tif err == store.ErrIndexNotFound {\n\t\tfmt.Println(\"Successfully caught ErrIndexNotFound for lookup.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\t// Try to drop a non-existent index\n\terr = s.DropIndex(\"another_non_existent_index\")\n\tif err == store.ErrIndexNotFound {\n\t\tfmt.Println(\"Successfully caught ErrIndexNotFound for drop.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "The `indexName` provided does not match any index currently managed by the `Store`."
        }
      ],
      "diagnosis": "Verify the `indexName` spelling and confirm that the index was indeed created before attempting to use or drop it.",
      "resolution": "Ensure the index is created successfully with `CreateIndex` before performing `Lookup`, `LookupRange`, or `DropIndex` operations. Correct the `indexName` if misspelled.",
      "prevention": "Centralize index creation during application startup. Implement checks for index existence if dynamic index management is required.",
      "handlingPatterns": "Catch `ErrIndexNotFound` and provide user feedback (e.g., \"Index not found\"). For idempotent operations like dropping an index, you might ignore this error if the goal is simply to ensure the index is not present.",
      "propagationBehavior": "Bubbles up to the caller of the respective `Store` method.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:DropIndex",
          "method:Lookup",
          "method:LookupRange"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrStreamClosed": {
      "id": "error:ErrStreamClosed",
      "type": "error",
      "symptoms": "Returned by `DocumentStream.Next()` when all documents have been consumed from the stream, or the `DocumentStream.Close()` method has been called, or the `Store` itself has been closed.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Attempting to call `DocumentStream.Next()` after the stream has delivered all documents.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\t_, _ = s.Insert(store.Document{\"test\": 1})\n\n\tstream := s.Stream(0)\n\t_, _ = stream.Next() // Consume the only document\n\n\t_, err := stream.Next() // Call again when exhausted\n\tif err == store.ErrStreamClosed {\n\t\tfmt.Println(\"Caught ErrStreamClosed after stream exhausted.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "The internal channel feeding the stream has been closed, indicating no more `DocumentResult` values will be sent."
        },
        {
          "trigger": "Attempting to call `DocumentStream.Next()` after `DocumentStream.Close()` has been explicitly called.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\tstream := s.Stream(0) // Unbuffered stream to easily block Next()\n\n\tgo func() {\n\t\t// In a real scenario, this goroutine might be waiting for documents\n\t\t_, err := stream.Next()\n\t\tif err == store.ErrStreamClosed {\n\t\t\tfmt.Println(\"Goroutine caught ErrStreamClosed due to explicit stream close.\")\n\t\t} else {\n\t\t\tfmt.Printf(\"Goroutine caught unexpected error: %v\\n\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(10 * time.Millisecond) // Allow goroutine to reach Next()\n\tstream.Close() // Explicitly close the stream\n\n\ttime.Sleep(10 * time.Millisecond) // Allow goroutine to finish\n}",
          "reason": "The stream's `Close()` method explicitly signals termination."
        }
      ],
      "diagnosis": "This error typically signifies the end of a stream. If it occurs unexpectedly, check if `DocumentStream.Close()` is being called prematurely or if the producing goroutine is exiting early.",
      "resolution": "Use `ErrStreamClosed` as the loop termination condition for consuming streams. Ensure `DocumentStream.Close()` is called only when the stream is truly no longer needed.",
      "prevention": "Always `defer stream.Close()` immediately after creating a stream. Structure stream consumption loops to gracefully break on `ErrStreamClosed`.",
      "handlingPatterns": "The standard pattern is `for { doc, err := stream.Next(); if err != nil { if err == store.ErrStreamClosed { break }; // handle other errors; break }; // process doc }`.",
      "propagationBehavior": "Bubbles up to the caller of `DocumentStream.Next()`.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:DocumentStream.Next"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrStoreClosed": {
      "id": "error:ErrStoreClosed",
      "type": "error",
      "symptoms": "Any `Store` method (`Insert`, `Get`, `Update`, `Delete`, `Stream`, `CreateIndex`, `DropIndex`, `Lookup`, `LookupRange`) returning `ErrStoreClosed`.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Attempting to perform any operation on a `Store` instance after its `Close()` method has been called.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\ts.Close() // Close the store immediately\n\n\t_, err := s.Insert(store.Document{\"foo\": \"bar\"})\n\tif err == store.ErrStoreClosed {\n\t\tfmt.Println(\"Successfully caught ErrStoreClosed.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "The store's internal `closed` atomic flag has been set to `true`, indicating it's no longer operational."
        }
      ],
      "diagnosis": "This indicates an attempt to interact with a store instance that has already been shut down. Review the lifecycle of your `Store` instance.",
      "resolution": "Ensure `Store` operations are only performed on an active, open store. If a store needs to be reused after closing, a new `Store` instance must be created with `NewStore()`.",
      "prevention": "Place `defer s.Close()` immediately after `s := store.NewStore()`. Ensure references to the `Store` instance are correctly scoped or nullified after closure to prevent accidental reuse.",
      "handlingPatterns": "Typically indicates a programming error or an attempt to use a shared resource after it's been disposed. Handle by logging or returning a fatal error, as operations on a closed store are generally unrecoverable.",
      "propagationBehavior": "Bubbles up to the caller of the `Store` method.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:Insert",
          "method:Get",
          "method:Update",
          "method:Delete",
          "method:Stream",
          "method:CreateIndex",
          "method:DropIndex",
          "method:Lookup",
          "method:LookupRange"
        ],
        "patterns": [],
        "errors": []
      }
    },
    "ErrInvalidDocument": {
      "id": "error:ErrInvalidDocument",
      "type": "error",
      "symptoms": "Calling `Insert` or `Update` with a `nil` `store.Document`.",
      "properties": "Standard Go `error` interface. No additional properties.",
      "scenarios": [
        {
          "trigger": "Passing `nil` as the `doc` parameter to `Insert` or `Update`.",
          "example": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\tstore \"github.com/asaidimu/go-store/v3\"\n)\n\nfunc main() {\n\ts := store.NewStore()\n\tdefer s.Close()\n\n\t_, err := s.Insert(nil) // Invalid\n\tif err == store.ErrInvalidDocument {\n\t\tfmt.Println(\"Caught ErrInvalidDocument for Insert with nil doc.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tid, _ := s.Insert(store.Document{\"a\":1})\n\terr = s.Update(id, nil) // Invalid\n\tif err == store.ErrInvalidDocument {\n\t\tfmt.Println(\"Caught ErrInvalidDocument for Update with nil doc.\")\n\t} else if err != nil {\n\t\tlog.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}",
          "reason": "The store expects valid document data (a `map[string]any`) for insertion and update operations to ensure data integrity."
        }
      ],
      "diagnosis": "Check the value of the `doc` parameter before calling `Insert` or `Update`. Ensure it is a properly initialized `store.Document` (or `map[string]any`) and not `nil`.",
      "resolution": "Always pass a non-`nil` `store.Document` to `Insert` and `Update`. Even if the document has no fields, pass an empty map: `store.Document{}`.",
      "prevention": "Implement input validation on user-provided document data if it can potentially be `nil`.",
      "handlingPatterns": "Catch `ErrInvalidDocument` and provide specific feedback that the document content cannot be empty or invalid. Prevent the call from happening with a client-side check.",
      "propagationBehavior": "Bubbles up to the caller of `Insert` or `Update`.",
      "related": {
        "interfaces": [],
        "interface": [],
        "methods": [
          "method:Insert",
          "method:Update"
        ],
        "patterns": [],
        "errors": []
      }
    }
  }
}